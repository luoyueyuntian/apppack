### 微信小程序如何跨页面传参
微信小程序每个页面都有自己的作用域，各个页面之间是隔离的，无法访问到其他页面的数据。但每个页面都可以拿到应用的实例，所以在app上保存要共享的数据是一个可以跨页面共享数据的方式。例如小程序官方示例上的globalData：

<pre><code>// app.js
App({
  onLaunch (options) {
    // Do something initial when launch.
  },
  onShow (options) {
    // Do something when show.
  },
  onHide () {
    // Do something when hide.
  },
  onError (msg) {
    console.log(msg)
  },
  globalData: 'I am global data'
})
</code></pre>

当应用变的复杂时，随处添加全局属性，是有命名冲突的风险的。为了避免这个问题，所有的新增全局属性都应该统一个地方去定义和初始化，这样就可以看到别人已经使用过的全局属性，再加上一些其他的检测手段（比如Eslint的对象属性不能重复）可以避免命名冲突的问题。但每次加的时候，都要改动`app.js`也不太好，因为`app.js`本身会有一些逻辑，如果改动了，就需要对这一块的逻辑做一些测试。最好的方式是把全局共享变量的逻辑移到一个单独的文件，与`app.js`分离开来，这样就不用每次加全局属性的时候还要去测`app.js`模块的逻辑。

除此之外，还有一个方式，就是单独定义一个数据共享的模块，这个模块也不用挂载到整个app上，当需要跨页面共享数据时，就引入这个模块，从这个模块中存取数据，这样就完全和`app.js`脱离关系了，但为了避免冲突的问题，还是需要将用到的共享数据在模块里预先定义，而不是动态添加。

### 微信小程序前后端交互时如何保存用户状态？
一个web应用的登录过程应该是这样的：用户在客户端输入用户名和密码，提交到后端校验，后端校验通过后会在缓存中生成用户的session，每个session会由一个sessionId，在登陆接口返回时，响应报文中会增加一个set-cookie字段，把sessionId放到cookie中，浏览器收到服务端的响应后，就会把set-cookie里面的内容写到浏览器cookie中，后续浏览器每次发送到服务器的请求就会默认带上cookie，服务端通过cookie拿到sessionId，这样就可以知道用户的身份了。

而在微信小程序中，没有对cookie自动存储，也不存在每次请求时自动带上cookie。所以我们需要做两件事：1）在拿到用户cookie后保存用户cookie；2）每次发送请求时在请求头里加上cookie

为了做到这个，我们需要对请求方法做一下封装：

<pre><code>sessionid = global.sessionid    // global对应于全局变量，可以是一个数据共享模块，也可以是getApp()下面的一个属性
const request = (option) => {
    return new Promise((resolve, reject) => {
        const { url = '', data = {}, method = 'POST', contentType = 'application/json' } = option
        wx.request({
            url: url.indexOf('nextpay') > -1 ? getsfpayUrl(url): getUrl(url),
            data,
            method,
            header: {
                'content-type': contentType,
                'Accept': 'application/json',
                'sessionid': sessionid
            },
            success: res => {
                resolve(res)
            },
            fail: err => {
                reject(err)
            }
        })
    })
}
</code></pre>
当我们需要发送请求时，应该使用封装好的`request`方法，而不是直接使用`wx.request`

### 小程序登录问题


### 修改自带表单`checkbox`样式
<pre><code>.checkbox {
    .wx-checkbox-input {
        //wx-checkbox .wx-checkbox-input 覆盖原生样式
        width: 28rpx;
        height: 28rpx;
        margin-bottom: 8rpx;
        border: 1px solid #999999;

        &.wx-checkbox-input-checked {
            color: #FFFFFF;
            background-color: #CC3244;
            border: 1px solid #CC3244;

            &::before {
                font-size: 28rpx;
            }
        }
    }
}</code></pre>

### canvas画图保存成临时文件，图片画不上的问题
一般在使用canvas画图时，在最后我们都会调用`CanvasContext.draw`完成图片的绘制，从官方api文档上看，`CanvasContext.draw(boolean reserve, function callback)`是一个异步的方法，画完之后在回调中对图片进行处理，本来按api的定义，这个在callback执行的时候，图片已经画完了，但实际使用过程中，经常会出现在canvas中使用图片，但图片没有画上去的问题，这个说明小程序在判断图片是否已经画完的时机上不是很准确，为了保证能够将图片未画上去的概率降到足够低，一般需要给一个500-1000毫秒的延迟。
<pre><code>const ctx = wx.createCanvasContext('myCanvas')
// …… 其他绘图代码
ctx.draw(true, () => setTimeout(callback, 500))
</code></pre>

### 视频全屏播放时没有自动根据视频宽高横屏的问题
从官方的文档上看，`video`组件有一个`direction`属性，设置全屏时视频的方向，不指定则根据宽高比自动判断，但实际使用中并不会自动根据宽高比选择合适的视频方向，对于这个问题，如果你能知道视频实际的宽高，通过判断确定合适的方向，自己实现根据宽高比例选择合适的视频方向。

### 如何使用隐藏的canvas画图
canvas要在显示状态下绘图，如果你希望某个页面的分享图片是动态绘制的，需要使用canvas去动态绘制，但你又不希望canvas显示在页面上，可以通过绝对定位把canvas移到窗口外面，比如`left: -1000rpx`，这样就可以正常的使用canvas画图。

### tab页使用webview时，左上角没有返回按钮的问题
tab页属于一级页面，无法再后退，左上角页不会有返回按钮，在tab页使用webview时，路由到其他页面后，通过系统的返回键，可以返回到h5上一页，但在小程序上，不会显示返回按钮。

解决方案：二级页面是可以有返回按钮的，这个是我们现有的小程序上可以得到验证的。新建一个页面用来承接webview页，一级页面webview点击跳转统一改到跳转到二级webview页面，这样就有了返回按钮，并且返回时也能够正常返回到一级tab页面。

