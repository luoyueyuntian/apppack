### 微信小程序如何维持登录状态
登录是为了获取用户身份，在web端，我们不希望用户频繁登录，影响用户体验，会维持登录状态一段时间，比如说关掉网页前，或者说连续半个小时没有任何操作，这个需要后端去控制session过期时间，有的会维持登录的时间更长一些，可以通过给cookie设置过期时间来实现。在微信小程序（微信公众号同样）端，我们希望能够维持登录更长的时间，就需要充分利用微信的机制。

在启动微信小程序后，我们会调用wx.login拿到code，调用后端接口，后端通过前端下发的code已经appid和加密字符串（一段自定义字符串，在微信小程序开发管理平台配置），调用微信接口，拿到用户oppenId和sessionKey，比较有用的是这个oppenId，这个是一个用户标志，是根据用户微信号生成的，这个本时就是一个用户身份，但如果仅仅依赖这个身份，会有一些其他的问题，一个是用户不能在你的小程序里面登录其他用户，只能通过切换微信账号的方式；另一个问题是你的数据无法多端打通，比如和app打通数据，和PC端打通，因为他们之间的账号无法关联起来。这个时候，我们需要在微信小程序里面再建一套用户体系。一般通过用户手机号为用户建立会员体系，原因是工信部要求网上用户必须实名，而手机号是已经实名了的，所以关联手机号，相当于间接实名，而且所有网站、app都有这样的要求，那么都通过手机号，就很容易关联各个应用的数据。手机号登录有两种模式，一个是手机+手机验证码，一个是通用微信的开发接口，通过微信授权拿到用户的手机号，这两个方式都可以确定用户对某个手机号拥有控制权，一般都是同时提供这两种方式。用户登录后，当然会给用户一个新的sessionId，这样后面的请求就可以识别到用户新的身份，用户所有的操作都会关联到一个新的用户下面。以上这些都是常规操作，但对于下一次用户打开小程序，这个时候你只能拿到用户的oppenId，这个是通过微信号建立的一个会员体系，有一些不足，而我们已经再微信上面根据手机号建立了一套用户体系了，问题是通过微信那边现在只能拿到用户的oppenid，为了能正确识别到用户的登录手机号用户，需要用户在小程序登录手机后用户时，后端就把用户的手机号和oppenid关联起来，这样拿到oppenid，就能知道用户的登录手机号，这样就可以返回用户登录手机号对应账号的sessionid，这个账号机制还是基于微信平台，因为用户的oppenid是来自微信，你只要信任微信的账号体系，那么这么做当然没问题。用户手机号与openid关联，只要用户不明确退出账户，就不解绑二者的关系，那么你总能在根据openid拿到用户绑定的手机号，也就只知道用户的身份。而用户在小程序解绑后，就又会回到微信的账户体系。当然用户绑定新的手机号，则会切换到新手机号对应的账号。但是如果你使用基于手机号的用户体验，那么会话安全的事情就需要自己处理，比如用户长时间没有操作，那么就需要让用户的会话过期，如果要恢复会话，就必须走微信的机制，调用wx.login，得到code后，让后端重新从微信那边拿到openid，并刷新sessionId。

### 微信小程序如何跨页面相互传参
如果是从A页面跳转到B页面，可以通过路径上加参数处理，如果是B页面返回A页面，则必须自己想办法。而且从A页面到B页面，参数只是是键值对，而且值只能是字符串，如果是对象，则要通过JSON.stringfy序列化成字符串，到B页面后再解析成对象形式。从B页面返回到A页面，小程序框架没有提供直接的方式，要处理好这个问题，需要做两件事，一个是判断页面是否是从B返回A，我在A页面的onShow中判断，但onShow可能发生在页面第一次加载，也可能发生在整个应用从后台切换到前台，也可能是从B以外的页面返回，所以不能每次A onShow的时候，就当作从B返回处理，这个时候可以通过在A页面加一个状态，这个状态默认为false，当A页面跳转到B页面时，就将这个状态设为true，这样当B页面返回到A页面时，就可以通过这个状态来判断是否是从B返回，因为这个状态只在从A离开到B页面返回之间这段时间为true，当从B页面返回后，我们用完这个状态后要立即将这个状态重置为false，以保证这个状态只在从A页面跳转到B页面直至从B页面返回到A页面这段时间之间为true,这样其他情况下A的onShow读到的状态都为false，就不会去处理取B传给A的参数。
第二个问题是这个参数，微信小程序每个页面都有自己的作用域，各个页面之间是隔离的，无法访问到其他页面的数据。但每个页面都可以拿到应用的实例，所以在app上保存要共享的数据是一个可以跨页面共享数据的方式。例如小程序官方示例上的globalData：

<pre><code>// app.js
App({
  onLaunch (options) {
    // Do something initial when launch.
  },
  onShow (options) {
    // Do something when show.
  },
  onHide () {
    // Do something when hide.
  },
  onError (msg) {
    console.log(msg)
  },
  globalData: 'I am global data'
})
</code></pre>

当应用变的复杂时，随处添加全局属性，是有命名冲突的风险的。为了避免这个问题，所有的新增全局属性都应该统一个地方去定义和初始化，这样就可以看到别人已经使用过的全局属性，再加上一些其他的检测手段（比如Eslint的对象属性不能重复）可以避免命名冲突的问题。但每次加的时候，都要改动`app.js`也不太好，因为`app.js`本身会有一些逻辑，如果改动了，就需要对这一块的逻辑做一些测试。最好的方式是把全局共享变量的逻辑移到一个单独的文件，与`app.js`分离开来，这样就不用每次加全局属性的时候还要去测`app.js`模块的逻辑。

除此之外，还有一个方式，就是单独定义一个数据共享的模块，这个模块也不用挂载到整个app上，当需要跨页面共享数据时，就引入这个模块，从这个模块中存取数据，这样就完全和`app.js`脱离关系了，但为了避免冲突的问题，还是需要将用到的共享数据在模块里预先定义，而不是动态添加。

### 微信小程序前后端交互时如何保存用户状态？
一个web应用的登录过程应该是这样的：用户在客户端输入用户名和密码，提交到后端校验，后端校验通过后会在缓存中生成用户的session，每个session会由一个sessionId，在登陆接口返回时，响应报文中会增加一个set-cookie字段，把sessionId放到cookie中，浏览器收到服务端的响应后，就会把set-cookie里面的内容写到浏览器cookie中，后续浏览器每次发送到服务器的请求就会默认带上cookie，服务端通过cookie拿到sessionId，这样就可以知道用户的身份了。

而在微信小程序中，没有对cookie自动存储，也不存在每次请求时自动带上cookie。所以我们需要做两件事：1）在拿到用户cookie后保存用户cookie；2）每次发送请求时在请求头里加上cookie

为了做到这个，我们需要对请求方法做一下封装：

<pre><code>sessionid = global.sessionid    // global对应于全局变量，可以是一个数据共享模块，也可以是getApp()下面的一个属性
const request = (option) => {
    return new Promise((resolve, reject) => {
        const { url = '', data = {}, method = 'POST', contentType = 'application/json' } = option
        wx.request({
            url: url.indexOf('nextpay') > -1 ? getsfpayUrl(url): getUrl(url),
            data,
            method,
            header: {
                'content-type': contentType,
                'Accept': 'application/json',
                'sessionid': sessionid
            },
            success: res => {
                resolve(res)
            },
            fail: err => {
                reject(err)
            }
        })
    })
}
</code></pre>
当我们需要发送请求时，应该使用封装好的`request`方法，而不是直接使用`wx.request`

### 小程序登录问题
小程序的登录除了传统的用户输入用户名和密码发送到后端校验的方式外，还有一个就是微信提供的授权获取用户手机号，用户授权后，微信会提供加密后的用户手机号等信息，前端调用后端接口把获取的加密数据传给后端，后端解析出手机号等信息后可直接生成用户登录信息，并在接口中将用户session-id返回给前端。在这里值得说的一点是，这个方案为什么是安全的，也就是不会被伪造登录，因为这里的登录没有输入用户名和密码，如何保证用户不会登录其他人的账户。首先授权获取用户手机号这里，微信返回给用户的手机号不是随意的，而是默认返回的用户登录的微信所绑定的手机号，这个手机号是做用用户验证的，非本人是不能随便绑定手机号的，而如果要使用其他手机号则需要通过动态验证码来校验，所以到此为止，我们知道这个手机号不是随便来的。其次，微信给的手机号是加密数，这个只能是后端通过session_key和app_id来进行解密获取，也就是说这个加密数据也是不能伪造的，因为加密过程是不透明的，不清楚加密方式，将数据加密后进行登录，很可能后端按照正常操作无法解密数据，这个自然就不会正常给用户生成session，所以基本也很难绕过微信来随意登录任意账号。

### 修改自带表单`checkbox`样式
<pre><code>.checkbox {
    .wx-checkbox-input {
        //wx-checkbox .wx-checkbox-input 覆盖原生样式
        width: 28rpx;
        height: 28rpx;
        margin-bottom: 8rpx;
        border: 1px solid #999999;

        &.wx-checkbox-input-checked {
            color: #FFFFFF;
            background-color: #CC3244;
            border: 1px solid #CC3244;

            &::before {
                font-size: 28rpx;
            }
        }
    }
}</code></pre>

### canvas画图保存成临时文件，图片画不上的问题
一般在使用canvas画图时，在最后我们都会调用`CanvasContext.draw`完成图片的绘制，从官方api文档上看，`CanvasContext.draw(boolean reserve, function callback)`是一个异步的方法，画完之后在回调中对图片进行处理，本来按api的定义，这个在callback执行的时候，图片已经画完了，但实际使用过程中，经常会出现在canvas中使用图片，但图片没有画上去的问题，这个说明小程序在判断图片是否已经画完的时机上不是很准确，为了保证能够将图片未画上去的概率降到足够低，一般需要给一个500-1000毫秒的延迟。
<pre><code>const ctx = wx.createCanvasContext('myCanvas')
// …… 其他绘图代码
ctx.draw(true, () => setTimeout(callback, 500))
</code></pre>

### 视频全屏播放时没有自动根据视频宽高横屏的问题
从官方的文档上看，`video`组件有一个`direction`属性，设置全屏时视频的方向，不指定则根据宽高比自动判断，但实际使用中并不会自动根据宽高比选择合适的视频方向，对于这个问题，如果你能知道视频实际的宽高，通过判断确定合适的方向，自己实现根据宽高比例选择合适的视频方向。

### 如何使用隐藏的canvas画图
canvas要在显示状态下绘图，如果你希望某个页面的分享图片是动态绘制的，需要使用canvas去动态绘制，但你又不希望canvas显示在页面上，可以通过绝对定位把canvas移到窗口外面，比如`left: -1000rpx`，这样就可以正常的使用canvas画图。

### tab页使用webview时，左上角没有返回按钮的问题
tab页属于一级页面，无法再后退，左上角页不会有返回按钮，在tab页使用webview时，路由到其他页面后，通过系统的返回键，可以返回到h5上一页，但在小程序上，不会显示返回按钮。

解决方案：二级页面是可以有返回按钮的，这个是我们现有的小程序上可以得到验证的。新建一个页面用来承接webview页，一级页面webview点击跳转统一改到跳转到二级webview页面，这样就有了返回按钮，并且返回时也能够正常返回到一级tab页面。

### IOS动态修改微信小程序tabbar失败，无异常
如果希望为不同的用户提供不同的功能，比如小程序加载后通过灰度查询，确定一个用户是否在新功能的灰度内，如果在，就修改tabbar，展示其他内容，但是IOS中修改失败，并且还执行了success回调。解决办法，修改tabbar的icon使用的图片路径是相对路径，改为绝对路径后可正常修改。

### 部分IOS机型调用相机扫码完成后跳转页面时页面onShow、onHide执行顺序和其他页面不一致问题
微信小程序没有路由事件，如果你跳转到其他页面编辑一个数据，希望返回时能带一些数据，如果有引入状态管理工具，这个还好办，如果自己去做，就需要做两件事，一是判断出页面是否是从另一个页面返回，这个大多数情况可以通过onShow加一些辅助的状态来判断，二是数据的传递，这个问题前面有专门叙述，通过加状态可以在onShow里判断出是否是从特定页面返回，数据的存放是要放在两个页面都能放问到的公共空间。采用这种方式，在大多数情况下的时候是没有问题的，但是在调用相机时，小程序会切到后台，整个小程序会page onHide，app onHide,相机使用完成后会app onShow, page onShow,如果是希望在相机扫完码后跳转到一个页面，则需要在使用完相机返回后设置状态，不然相机返回时会调用一次page onShow，这个时候按照逻辑，会误任务从其他页面返回，会把状态重置为false，这个时候再跳到其他页面返回时，读到的状态就已经时false了，就不会再去取参数了。

### 哀悼日小程序所有图片快速置灰功能
今天清明节，因为新冠疫情影响，举国降半旗，领导突然早上打电话要求将app全部置灰，看半个小时能不能解决，事发紧急，我们结合全组研发智慧，提出了两种方案，一个是全局增加不透明度，但效果不太理想，另一个就是把所有的图片应用滤镜置灰，效果满足要求。


微信小程序提供了可以设置全局样式的`app.wxss`文件，写在这个文件里的样式作用于全局，利用css可以在全局的样式文件里面给所有的图片应用滤镜，将所有图片置灰，代码如下:
<pre><code>.gray { 
    -webkit-filter: grayscale(100%);
    -moz-filter: grayscale(100%);
    -ms-filter: grayscale(100%);
    -o-filter: grayscale(100%);
    
    filter: grayscale(100%);
	
    filter: gray;
}
</code></pre>
参考[小tip: 使用CSS将图片转换成黑白(灰色、置灰)](https://www.zhangxinxu.com/wordpress/2012/08/css-svg-filter-image-grayscale/)
