## 浏览器的主要功能和主流浏览器内核
+ 浏览器主要功能：向服务器发出请求，在浏览器窗口中展示您选择的网络资源

+ 用户界面：地址栏、前进和后退按钮、书签、刷新及取消按钮、主页

## 五大主流浏览器：
Chrome、Internet Explorer、Firefox,、Safari 、Opera


## 四大内核：
Trident(IE)、webkit(Safari、 Chrome )、Blink(Opera)、Gecko(Firefox) 



## 浏览器架构

大家所理解的进程和线程是怎样的？
浏览器是多进程还是单线程？


### 区分进程和线程
#### 进程
+ 进程是一个工厂，工厂有它的独立资源
+ 工厂之间相互独立
+ 线程是工厂中的工人，多个工人协作完成任务
+ 工厂内有一个或多个工人
+ 工人之间共享空间


#### 线程
+ 工厂的资源 -> 系统分配的内存（独立的一块内存）
+ 工厂之间的相互独立 -> 进程之间相互独立
+ 多个工人协作完成任务 -> 多个线程在进程中协作完成任务
+ 工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成
+ 工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等））

进程是cpu资源分配的最小单位（是能拥有资源和独立
运行的最小单位）

线程是cpu调度的最小单位（线程是建立在进程的基础
上的一次程序运行单位，一个进程中可以有多个线程）



## 多进程的浏览器

+ Browser进程：浏览器的主进程（负责协调、主控），只有一个；负责包括地址栏、
书签栏、前进后退按钮等部分的工作，负责处理浏览器的一些不可见的底层操作，比
如网络请求和文件访问
+ 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
+ GPU进程：负责处理 GPU 相关的任务
+ 浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，
脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）


### 浏览器多进程的优势
+ 避免单个page crash影响整个浏览器
+ 避免第三方插件crash影响整个浏览器
+ 多进程充分利用多核优势
+ 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

## 导航过程发生了什么

### 处理输入
UI thread 需要判断用户输入的是 URL 还是 query， 
UI thread 决定是搜索内容到搜索引擎还是去一个网站

### 开始导航

当用户点击回车键， UI thread 通知 network thread获取网页内容，并控制 tab 上的 spinner 展现，表示正在加载中

network thread 会执行 DNS 查询，随后为请求建立 TLS 连接

如果 network thread接收到了重定向请求头如 301， network thread 会通知 UI thread 服务器要求重定向，之后，另外一个 URL 请求会被触发

### 读取响应
当请求响应返回的时候，network thread 会依据 Content-Type 及 MIME Type sniffing 判断响应内容的格式

如果响应内容的格式是 HTML ，下一步将会把这些数据传递给 renderer process，如果是 zip 文件或者其它文件，会把相关数据传输给下载管理器

Safe Browsing 检查也会在此时触发，如果域名或者请求内容匹配到已知的恶意站点，network thread 会展示一个警告页。此外 CORB 检测也会触发确保敏感数据不会被传递给渲染进程


### 查找渲染进程
一旦所有的检查处理完毕并且 UI thread 确定会导航到请求的站点， network thread 会告诉 UI thread 所有的数据请求完毕。UI thread 会寻找渲染进程开始渲染Web页面

由于网络请求获取响应需要时间，这里其实还存在着一个加速方案。当 UI thread 发送 URL 请求给 network thread 时，浏览器其实已经知道了将要导航到那个站点。UI thread 会并行的预先查找和启动一个渲染进程，如果一切正常，当 network thread 接收到数据时，渲染进程已经准备就绪了，但是如果遇到重定向，准备好的渲染进程也许就不可用了，这时候就需要重启一个新的渲染进程

现在数据和渲染进程就绪， Browser Process 会给 renderer process 发送 IPC 消息来确认导航，一旦 Browser Process 收到 renderer process 的渲染确认消息，导航过程结束，页面加载过程开始

此时，地址栏会更新，展示出新页面的网页信息。history tab 会更新，可通过返回键返回导航来的页面，为了让关闭 tab 或者窗口后便于恢复，这些信息会存放在硬盘中



###  额外的步骤
一旦导航被确认，renderer process 会使用相关的资源渲染页面，下文中我们将重点介绍渲染流程。当 renderer process 渲染结束（渲染结束意味着该页面内的所有的页面，包括所有 iframe 都触发了onload 时），会发送 IPC 信号到 Browser process， UI thread 会停止展示 tab 中的 spinner

###  导航到另一个站点

在这里我们可以明确一点，所有的 JS 代码其实都由 renderer Process 控制的，所以在你浏览网页内容的过程大部分时候不会涉及到其它的进程。不过也许你也曾经监听过 beforeunload 事件，这个事件再次涉及到 Browser Process 和 renderer Process 的交互，当当前页面关闭时（关闭 Tab ，刷新等等），Browser Process 需要通知 renderer Process 进行相关的检查，对相关事件进行处理
befounload事件会在用户离开或者关闭标签页面时候给予提醒“离开此站点”


## http 请求全过程

### DNS 解析过程

输入一个URL，发起请求，其实接收请求的最终一个服务器，而每个服务器都一个IP地址，所以一般一个域名对一个一个IP地址(也有对应多个IP地址的，我们暂时值分析对一个IP地址的情况)， 但是浏览器怎么知道域名到底对应的是那个IP地址呢，这个就是涉及到怎么去域名解析了。 域名解析主要是如下过程：
1. 通过浏览器缓存来查找，如果缓存中存在，则就不会继续查找，直接用查找到的IP地址，我们可以在 Chrome 中查看我们浏览器中缓存的所有的DNS. 
2. 如果浏览器没有查找到，我们就会在我们电脑中去查找是否保存了对应的域名信息
3. 如果本地没有保存，就会从路由器去查找
4. 如果路由器都没有，就会去 ISP 中查找

从上页分析可知，我们输入一个域名需要去做DNS解析找到IP，但是在我们的代码中，经常将一些静态资源放在CDN中，每个CDN地址我们都要去做下DNS解析，这个会浪费时间，我们可以通过预先进行DNS解析，然后在请求的时候，DNS已经解析完成就不用等待了

<pre><code>&lt;!--在head标签中，越早越好--	&gt;
&lt;link rel="dns-prefetch" href=“http://www.xxx.com"	&gt;
</code></pre>


### tcp 连接

第一次握手：建立连接

客户端发送连接请求报文段，将SYN值设为1，Sequence Number为x。客户端进入SYN_SEND状态，等待服务器的确认

第二次握手：服务器收到SYN报文段

服务器收到客户端SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)。同时，自己自己还要发送SYN请求信息，将SYN值设为1，Sequence Number设为y。服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，服务器进入SYN_RECV状态。

第三次握手：客户端收到SYN+ACK报文段

客户端收到服务器的SYN+ACK报文段后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手

#### 为什么是三次握手？为什么不是两次、四次或者五次呢？

client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。所以，“三次握手”的目的是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误



+ 在 HTTP/1.0 时代，每一个请求都会重新建立一个 TCP 连接，一旦响应返回，就关闭连接，这种就是短连接，HTTP/1.1版本就支持Keep-Alive 模式，实现长连接了
+ HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽
+ HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求

### 四次挥手
1. 第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了
2. 第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求
3. 第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态
4. 第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了

#### 为什么是四次挥手？
TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化


## 浏览器渲染进程

### GUI渲染线程：

+ 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等
+ 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
+ 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行


### 事件触发线程：
+ 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
+ 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
+ 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
+ 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）


### 定时触发器线程：
+ 归传说中的 setInterval 与 setTimeout 所在线程
+ 浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
+ 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
+ 注意，W3C在 HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms


### 异步http请求线程：
+ 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求
+ 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。


## 渲染流程
1、解析html建立dom树

2、解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）

3、布局render树（Layout/reflow），负责各元素尺寸、位置的计算

4、绘制render树（paint），绘制页面像素信息

5、浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上

### 解析HTML，构建DOM树
Bytes  => characters  => tokens   => nodes   => DOM 

列举其中的一些重点过程：

1. Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符 
2. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集 
3. Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则 
4. DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样 例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象


### 解析CSS，生产CSS规则树

Bytes  => characters  => tokens   => nodes   => CSSOM 


### 构建 render 树
当DOM树和CSSOM都有了后，就要开始构建渲染树了，一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应，因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者display: none等


### 布局
知道每个节点已经对应的元素样式，不足以渲染页面。布局是计算几何元素形状的过程，主线程遍历DOM,计算样式并创建布局树，其中包含xy坐标和边框大小等信息，布局树可能与DOM树结构树类似，但它仅包含页面可见内容的信息。如果一个元素应用了 display：none，那么该元素不是布局树的一部分。类似地，如果应用了如 p::before{content:"Hi!"} 的伪类，则即使它不在 DOM 中，也包含于布局树中


#### 绘制
有了DOM、样式、布局树还不能画出页面，还不知道绘制的顺序。 例如，有的元素有了
z-index，简单从上到下绘制就会出现图层高低错误


在绘制步骤，主线程遍历布局树（Layout Tree）创建绘制记录（Paint Records），就像是背景优先，然后矩形，文字

渲染管道最重要的事情：每个步骤，都是前一个操作的结果用于后一个操作的数据。如果为元素设置动画，每一帧都要进行相同的处理操作，大多数浏览器刷新率为 60 次/秒（60 FPS）。帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适；帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异；帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感


### 合成帧
光栅化：现在知道了文档的结构，CSS,布局树，绘制顺序。就是将数据转化为物理设备上的像素了。这个过程成为光栅化

合成：合成处理是将页面的各个部分光栅化，并且合成线程进行图层移动合成

### 绘制
复合：复合是一种分割页面为不同的层，并单独栅格化，随后组合为帧的技术。不同层的组合由 compositor 线程（合成器线程）完成

分层：分层为了分清哪些元素位于什么图层，主线程遍历布局树创建图层树，如果某些部分是单独图层（例如划入式侧面菜单栏），但没有拆分出来，可以用CSS属性：will-change提示浏览器

一旦创建了图层树和确定了绘制顺序，主线程将会把信息传递给合成线程，接着，合成线程会光栅化每个图层，一个图层可能跟页面一样大，合成线程将其分块后发送给光栅线程。光栅线程光栅化每个小块后将他们存储在显存中

一旦块被光栅化，合成线程会收集这些块的信息（称为绘制四边形），创建合成帧
+ 绘制四边形：包含块在内存的位置，以及合成时块在页面中的位置等信息
+ 合成帧：一个绘制四边形的集合，代表一个页面的一帧

接着，合成帧通过IPC提交给浏览器进程，此时，可以在UI线程或者其他插件的渲染进程添加一个合成帧，这些合成器帧被送到GPU然后在屏幕上显示。如果收到滚动事件，合成帧会创建另一个合成帧到GPU


### Layout and Repaint
Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树
Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了

回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流， 所以优化方案中一般都包括，尽量避免回流


什么会引起回流？

1.页面渲染初始化

2.DOM结构改变，比如删除了某个节点

3.render树变化，比如减少了padding

4.窗口resize

5.最复杂的一种：获取某些属性，引发回流， 很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流， 但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括： 

+ offset(Top/Left/Width/Height) 
+ scroll(Top/Left/Width/Height)
+ cilent(Top/Left/Width/Height)
+ width,height
+ 调用了getComputedStyle()或者IE的currentStyle


回流一定伴随着重绘，重绘却可以单独出现

所以一般会有一些优化方案，如：
+ 减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新
+ 避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document
+ 避免多次读取offset等属性。无法避免则将它们缓存到变量
+ 将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高

注意：改变字体大小会引发回流


#### 普通层和复合层

渲染步骤中就提到了composite概念

可以简单的这样理解，浏览器渲染的图层一般包含两大类：普通图层以及复合图层
首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）

其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。

然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）

可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒

可以Chrome源码调试 -> More Tools -> Rendering -> Layer borders中看到，黄色的就是复合图层信息

##### 如何变成复合图层（硬件加速）：
+ 最常用的方式：translate3d、translateZ
+ opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
+ will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）
+ &lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;&lt;webgl&gt;等元素
+ 其它，譬如以前的flash插件


absolute和硬件加速的区别：

可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。所以，就算absolute中信息改变时不会改变普通文档流中render树，但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）
而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）


#### 复合图层的作用：
一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能

#### 使用复合图层需要注意的地方：
使用3D硬件加速提升动画性能时，最好给元素增加一个z-index属性，人为干扰复合层的排序，可以有效减少chrome创建不必要的复合层，提升渲染性能，移动端优化效果尤为明显

简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层


## JS引擎线程
解释 => 预处理  => 执行  => 回收   

JS是解释型语音，所以它无需提前编译，而是由解释器实时运行

JS的解释流程：
1. 读取代码，进行词法分析（Lexical analysis），然后将代码分解成词元（token）
2. 对词元进行语法分析（parsing），然后将代码整理成语法树（syntax tree）
3. 使用翻译器（translator），将代码转为字节码（bytecode）
4. 使用字节码解释器（bytecode interpreter），将字节码转为机器码

在正式执行JS前，还会有一个预处理阶段 （譬如变量提升，分号补全等）

分号补全：
JS执行是需要分号的，但为什么以下语句却可以正常运行呢？
原因就是JS解释器有一个Semicolon Insertion规则，它会按照一定规则，在适当的位置补充分号

譬如列举几条自动加分号的规则：
+ 当有换行符（包括含有换行符的多行注释），并且下一个token没法跟前面的语法匹配时，会自动补分号
+ 当有}时，如果缺少分号，会补分号
+ 程序源代码结束时，如果缺少分号，会补分号

变量提升：一般包括函数提升和变量提升

解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含以下概念：

+ 执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）
+ VO（变量对象）和AO（活动对象）
+ 作用域链
+ this机制

执行上下文可以理解为函数执行的环境，每一个函数执行时，都会给对应的函数创建这样一个执行环境

JS有执行上下文
+ 浏览器首次载入脚本，它将创建全局执行上下文，并压入执行栈栈顶（不可被弹出）
+ 然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部
+ 一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈。
+ 这样依次执行（最终都会回到全局执行上下文）


回收机制：

JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。

譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）

常用的两种垃圾回收规则是：
+ 标记清除
+ 引用计数

同步任务都在主线程上执行，形成一个执行栈

主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件

一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行

事件循环机制：
+ 我们知道JavaScript的一大特点就是单线程，而这个线程中拥有唯一的一个事件循环
+ JavaScript代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(task queue)来搞定另外一些代码的执行
+ 一个线程中，事件循环是唯一的，但是任务队列可以拥有多个
+ 任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs
+ macro-task大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering
+ micro-task大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)
setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务
+ 来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的
事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次从macro-task开始，找到其中一个任务队列执行完毕，然后再执行所有的micro-task，这样一直循环下去。
+ 其中每一个任务的执行，无论是macro-task还是micro-task，都是借助函数调用栈来完成

## 浏览器对事件的处理

### 理解非立即可滚动区
运行JS是渲染进程的主线程的工作，页面合成之后，注册了事件的区域叫做“非立即可滚动区”，合成器线程会通知渲染进程的主线程处理。没有输入事件没有发生在事件注册区域，合成器进程则不需要等待主线程，可以继续合成帧

#### 设置事件处理应该注意
接上一页的问题，你可以给事件监听添加一个 passive:true 选项 ，将这种负面效果最小化。这会提示浏览器你想继续在主线程中监听事件，但合成器不必停滞等候，可接着创建新的合成帧
<pre><code>document.body.addEventListener('touchstart', event => {
    if (event.target === area) {
        event.preventDefault()
    }
}, { passive: true })
</code></pre>

#### 查找事件对象
当组合器线程发送输入事件给主线程时，主线程首先会进行命中测试（hit test），来查找对应的事件目标，命中测试会基于渲染过程中生成的绘制记录（paint records）查找事件发生坐标下寻找的元素

#### 事件的优化
一般我们屏幕的刷新速率为 60 FPS，但是某些事件的触发量会不止这个值，出于优化的目的，Chrome 会合并连续的事件(如 wheel, mousewheel, mousemove, pointermove, touchmove )，并延迟到下一帧渲染时候执行 。而如 keydown, keyup, mouseup, mousedown, touchstart, 和 touchend 等非连续性事件则会立即被触发
